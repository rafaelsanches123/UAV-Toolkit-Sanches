package uav.mosa.module.path_planner;

import java.io.File;
import java.io.IOException;
import lib.uav.hardware.aircraft.Drone;
import lib.uav.reader.ReaderFileConfig;
import lib.uav.struct.constants.TypeCC;
import lib.uav.struct.constants.TypeOperationMode;
import lib.uav.struct.constants.TypePlanner;
import lib.uav.struct.geom.PointGeo;
import lib.uav.struct.mission.Mission;
import lib.uav.struct.mission.Mission3D;
import lib.uav.util.UtilRunThread;
import uav.mosa.module.mission_manager.MissionManager;

/**
 * Class models mission planner of drone avoiding obstacles.
 * @author Jesimar S. Arantes
 * @since version 1.0.0
 */
public abstract class Planner {
    
    final ReaderFileConfig config;
    final String dir;
    final Drone drone;
    final Mission3D waypointsMission;
    final Mission3D mission3D;
    final Mission missionGeo;
    final PointGeo pointGeo;

    /**
     * Class constructor
     * @param drone instance of the aircraft
     * @param waypointsMission waypoints of the mission
     * @since version 1.0.0
     */
    public Planner(Drone drone, Mission3D waypointsMission) {
        this.config = ReaderFileConfig.getInstance();
        this.dir = config.getDirPlanner();
        this.drone = drone;
        this.waypointsMission = waypointsMission; 
        this.mission3D = new Mission3D();
        this.missionGeo = new Mission();
        this.pointGeo = MissionManager.pointGeo;
    }
    
    /**
     * Clears log files generated by method
     * @since version 1.0.0
     */
    public abstract void clearLogs();
    
    /**
     * Get the mission Cartesian coordinates.
     * @return the mission3D
     * @since version 1.1.0
     */
    public Mission3D getMission3D(){
        return mission3D;
    }
    
    /**
     * Get the mission in geographical coordinates.
     * @return the missionGeo
     * @since version 1.1.0
     */
    public Mission getMissionGeo(){
        return missionGeo;
    }
    
    /**
     * Method that runs the path planner based on the type of operation mode and 
     * on the device used.
     * @return {@code true} if the execution was successful
     *         {@code false} otherwise
     * @since version 1.0.0
     */
    boolean execMethod(){
        try {
            boolean isPrint = false;
            boolean isPrintError = false;
            String cmd = "";
            if (config.getTypePlanner().equals(TypePlanner.HGA4M) || 
                    config.getTypePlanner().equals(TypePlanner.CCQSP4M)){
                if (config.getOperationMode().equals(TypeOperationMode.SITL)){
                    cmd = config.getCmdExecPlanner() + " local";
                } else if (config.getOperationMode().equals(TypeOperationMode.HITL) ||
                        config.getOperationMode().equals(TypeOperationMode.REAL_FLIGHT)){
                    if (config.getTypeCC().equals(TypeCC.INTEL_EDISON)){
                        cmd = config.getCmdExecPlanner() + " edison";
                    }
                }
            }else if (config.getTypePlanner().equals(TypePlanner.A_STAR4M)){
                cmd = config.getCmdExecPlanner();
            }else if (config.getTypePlanner().equals(TypePlanner.G_PATH_PLANNER4M)){
                cmd = config.getCmdExecPlanner();
            }
            UtilRunThread.dualSingleThreadWaitFor(cmd, new File(dir), isPrint, isPrintError);
            return true;
        } catch (IOException ex) {
            System.err.println("Error [IOException] execMethod()");
            ex.printStackTrace();
            return false;
        } catch (InterruptedException ex) {
            System.err.println("Error [InterruptedException] execMethod()");
            ex.printStackTrace();
            return false;
        }
    }
}
